<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>SNAKE</title>
		<style>
			body { margin: 0 }
			canvas { width: 100%; height: 100%}
		</style>
				
	</head>
	<body>
		<script src="js/pro.js"></script>
		
		<!-- SETTING SECTION -->
		View:
		<select id="SelectV">
		  <option value="0" select="selected">Perspective</option>
		  <option value="1">Above</option>
		  <option value="2">Snake</option>
		</select>
		
		<script>
			var PI = Math.PI
			var RIGHT = 0
			var UP = 1
			var LEFT = 2
			var DOWN = 3
			var t = 0 // time
			
			var groundX = 10
			var groundY = 0.5
			var groundZ = 10
			
			var segLen = 1
			var segRad = 0.4
			var muzzleRad= 0.2
			
			var lev = 0
			var listBody = []
			
			// movement's variables
			var step = 1
			var view = 0 // 0:perspective 1:above 2:POV
			var dir = RIGHT
			var prevDir = RIGHT
			var dirList = [0,0,0]
			
			var appleRadius = 0.12
			var appleTube = 0.22 // > appleRadius
			
			var sunPos = { x: 5, y: 8, z: 0 }
			var moonPos = { x: -5, y: 5, z: 2 }
			
			var scene = new THREE.Scene()
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 )

			var renderer = new THREE.WebGLRenderer()
			//renderer.setClearColor(0xEEEEEE);
			renderer.setSize( window.innerWidth, window.innerHeight )
			document.body.appendChild( renderer.domElement )
			
			// materials
			var c_green_grass = new THREE.MeshPhongMaterial({color:0x507500})
			var c_black = new THREE.MeshPhongMaterial({color:0x000000})
			var c_white = new THREE.MeshPhongMaterial({color:0xefefef})
			var c_green_skin = new THREE.MeshPhongMaterial({color:0x00f000})
			var c_red_dark = new THREE.MeshPhongMaterial({color:0xa00000})
			var c_pink = new THREE.MeshPhongMaterial({color:0xc05050})
			
			
			var c_apple = new THREE.MeshPhongMaterial( {color: 0xe01000} )
			var c_brown = new THREE.MeshPhongMaterial( {color: 0x6B4423} )
			
			var c_sun = new THREE.MeshPhongMaterial( {color: 0xffefef} )
			var c_moon = new THREE.MeshPhongMaterial( {color: 0x0050f0} )
			
			// ground
			var ground = new THREE.Mesh(new THREE.BoxGeometry(groundX,groundY,groundZ), c_green_grass)
			ground.position.y = -0.25			
			var gridHelper = new THREE.GridHelper( 10, 10, c_black, c_black);
			gridHelper.position.y=0.26
			ground.add( gridHelper );
			scene.add(ground)
			
			// centre of the SNAKE
			var pivotSnake = new THREE.Object3D()
			pivotSnake.position.set( 0.5, segLen/2, 0.5 )
			pivotSnake.rotation.z = -PI/2
			ground.add(pivotSnake)
			
			// Chin
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, 0, PI)
			var chin = new THREE.Mesh( geometry, c_green_skin )
			pivotSnake.add(chin)
			
			// centre of Head motion
			var pivotHead = new THREE.Object3D()
			pivotHead.position.y = -segLen/2
			chin.add(pivotHead)			
			
			// Head
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, PI, PI)
			var head = new THREE.Mesh( geometry, c_green_skin )
			head.position.y = segLen/2
			pivotHead.add(head)
			
			// Mouth (Chin + Head)
			var line = new THREE.Shape()
			line.moveTo( -segRad, -segLen/2 )
			line.lineTo( -muzzleRad, segLen/2 )
			line.lineTo( muzzleRad, segLen/2 )
			line.lineTo( segRad, -segLen/2)
			line.lineTo( -segRad, -segLen/2 )
			var extrudeSettings = { depth: -0.01, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var mouth_head = new THREE.Mesh( geometry, c_red_dark )
			var mouth_chin = new THREE.Mesh( geometry, c_red_dark )
			mouth_head.rotation.y = PI/2
			mouth_chin.rotation.y = PI/2
			head.add(mouth_head)
			chin.add(mouth_chin)
			
			// Tongue
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, -segLen/2 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var back_tongue = new THREE.Mesh( geometry, c_pink )
			back_tongue.rotation.y = PI/2
			back_tongue.position.x = -0.01
			chin.add(back_tongue)
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, segLen/2 )
			line.lineTo( -muzzleRad, segLen )
			line.lineTo( 0, 3*segLen/4 )
			line.lineTo( muzzleRad, segLen )
			line.lineTo( muzzleRad/2, segLen/2 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, 0 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var tongue = new THREE.Mesh( geometry, c_pink )
			tongue.rotation.y = PI/2
			tongue.position.x = -0.01
			chin.add(tongue)
			
			// Eyes
			var geometry = new THREE.SphereGeometry (segRad/4, 16, 16)
			var eyeR = new THREE.Mesh( geometry, c_white )
			eyeR.position.set(-segRad/2,0,segRad/2)
			head.add(eyeR)
			var eyeL = new THREE.Mesh( geometry, c_white )
			eyeL.position.set(-segRad/2,0,-segRad/2)
			head.add(eyeL)
			
			// function to create a new body Seg as child of ?parent
			var geometryBody = new THREE.CylinderGeometry( segRad-0.05, segRad, segLen, 32 )
			var newBodySeg = function (parent) {
				// pivotPoint
				var pivotBody = new THREE.Object3D()
				/*var geometry = new THREE.SphereGeometry( 0.2, 32, 32 )
				var pivotBody = new THREE.Mesh( geometry, c_skin )*/
				pivotBody.position.y = -segLen
				listBody.push( pivotBody )
				parent.add( pivotBody )
				// bodySeg
				var bodySeg = new THREE.Mesh( geometryBody, c_green_skin )
				pivotBody.add( bodySeg )
			}
			
			// Initial Body
			newBodySeg( chin )
			
			// Tail
			var geometry = new THREE.ConeGeometry( segRad, segLen, 32 )
			var tail = new THREE.Mesh( geometry, c_green_skin )
			tail.position.y = -segLen
			tail.rotation.z = PI
			listBody[ 0 ].add( tail )
			
			// levelUP : lev++, add BodySeg, (spawn of apple)
			var levelUP = function () {
				listBody[ lev ].remove( tail )	// remove tail
				newBodySeg( listBody[lev] )		// add bodySeg
				dirList.push( dirList[lev] )	// dirList.length ++
				lev++;
				listBody[ lev ].add( tail ) 	// addd tail at the end
			}
			
			// Apple
			var geometry = new THREE.TorusGeometry( appleRadius, appleTube, 32, 96 )
			var apple = new THREE.Mesh( geometry, c_apple )
			apple.position.set(0.5, 0, 0.5)
			apple.position.y = appleTube + groundY/2
			apple.rotation.x = -PI/2
			ground.add( apple )
			
			// Petiole
			var geometry = new THREE.ConeGeometry( 0.05, appleTube, 16 )
			var petiole = new THREE.Mesh( geometry, c_brown )
			petiole.rotation.x = -PI/4
			petiole.position.z = appleTube
			apple.add( petiole )

			// Camera
			camera.position.set(0,5,7)
			camera.lookAt( 0, 0, 0 )
			var refreshCamera = function (pos) {
				if ( view==2) { // POV
					if ( dir==RIGHT) {
						camera.position.set( pos.x-1, 1.5, pos.z )
						camera.lookAt( pos.x+2, 0, pos.z )
					}else if ( dir==LEFT ) {
						camera.position.set( pos.x+1, 1.5, pos.z )
						camera.lookAt( pos.x-2, 0, pos.z )
					}else if ( dir==UP ) {
						camera.position.set( pos.x, 1.5, pos.z+1 )
						camera.lookAt( pos.x, 0, pos.z-2 )
					}else if ( dir==DOWN ) {
						camera.position.set( pos.x, 1.5, pos.z-1 )
						camera.lookAt( pos.x, 0, pos.z+2 )
					}
				} else if ( view==0 ) { // perspective
					camera.position.set(0,5,7)
					camera.lookAt( 0, 0, 0 )
				} else if ( view==1 ) { // above
					camera.position.set(0,7,0) 
					camera.lookAt( 0, 0, 0 )
				}
			}
			document.getElementById("SelectV").onchange = function(event) {
				view = parseFloat( event.target.value )
				refreshCamera( pivotSnake.position )
			}

			// Light
			var sunLight = new THREE.DirectionalLight( c_sun, 1.5 );
			scene.add( sunLight );
			var moonLight = new THREE.DirectionalLight( c_moon, 0.5 );
			scene.add( moonLight );
			var sun = new THREE.Mesh( new THREE.SphereGeometry( 1.5, 32, 32 ), c_sun )
			scene.add( sun )
			var moon = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 32 ), c_moon )
			scene.add( moon )
			 
			document.addEventListener("keydown", onDocumentKeyDown, false)
			function onDocumentKeyDown(event) {
				var keyCode = event.which
				if ( view==2) { // relative movement (POV)
					if ( keyCode==39 ) dir = (dir+3)%4 // turn RIGHT
					else if ( keyCode==37) dir = (dir+1)%4 // turn LEFT
				} else { // absolute movement
					if (keyCode == 39) { // RIGHT
						dir = RIGHT
					} else if (keyCode == 40) { // DOWN
						dir = DOWN
					} else if (keyCode == 37) { // LEFT
						dir = LEFT
					} else if (keyCode == 38) { // UP
						dir = UP
					}
				}
				
				if ( keyCode>=37 && keyCode<=40 ) move()
				else console.log( "pressed key:", keyCode )
				
				if ( keyCode == 86 ) { // change view - v
					view = (view+1)%3 
					refreshCamera( pivotSnake.position )
				} else if ( keyCode == 13 ) levelUP() // level up - enter (test)
			}
			
			var checkPos = function (){
				if (pivotSnake.position.x >= groundX/2){
					pivotSnake.position.x = -groundX/2+0.5
				}
				if (pivotSnake.position.x < -groundX/2){
					pivotSnake.position.x = groundX/2-0.5
				}
				if (pivotSnake.position.z >= groundZ/2){
					pivotSnake.position.z = -groundZ/2+0.5
				}
				if (pivotSnake.position.z < -groundX/2){
					pivotSnake.position.z = groundX/2-0.5
				}
			}
			
			var move = function(){
				if ( dir == RIGHT ){ 		// RIGHT
					pivotSnake.position.x += step
				} else if ( dir == LEFT ){	// LEFT
					pivotSnake.position.x -= step
				} else if ( dir == DOWN ){	// DOWN
					pivotSnake.position.z += step
				} else if( dir == UP ){ 	// UP
					pivotSnake.position.z -= step
				}
				
				dirList.unshift(dir)
				dirList.pop()
				//console.log(dirList)
				
				pivotSnake.rotation.y = dirList[0] * PI/2
				if ( view==2 ) refreshCamera( pivotSnake.position )
				for ( var i=0; i<=lev; i++ ) {
					// dirList[0] is the head dir
					if ( dirList[i+1]==dirList[i] ) {
						// same direction of parent: straight
						listBody[i].rotation.x = 0
						listBody[i].children[0].rotation.x = 0
						listBody[i].children[0].position.set(0,0,0)
					} else {
						// turn!
						var diff = dirList[i+1] - dirList[i]
						if ( diff==-1 || diff==3 ) { // turn to RIGHT
							listBody[i].rotation.x = PI/2
							listBody[i].children[0].rotation.x = -PI/4
							listBody[i].children[0].position.set(0,-segLen/5,-segRad/3)
						} else if ( diff==1 || diff==-3 ) { // turn to LEFT
							listBody[i].rotation.x = -PI/2
							listBody[i].children[0].rotation.x = PI/4
							listBody[i].children[0].position.set(0,-segLen/5,segRad/3)
						}
					}
				}
			}
			
			
			var animate = function () {
				requestAnimationFrame( animate )
				checkPos()
				//move()
				
				// loop motion
				pivotHead.rotation.z = PI/6*Math.sin(t)+PI/6
				tongue.position.y = segLen/2*Math.sin(t)-segLen/2
				apple.position.y = Math.sin(t/2)/10+0.1 + appleTube+groundY/2
				apple.rotation.z += 0.05
				
				// light
				sunPos.y = 8*Math.sin(t/6)
				sunPos.z = 8*Math.cos(t/6)
				sun.position.set( sunPos.x, sunPos.y, sunPos.z )
				sunLight.position.set( sunPos.x, sunPos.y, sunPos.z )//.normalize()
				//moonPos.y = -8*Math.sin(t/5.5)
				//moonPos.z = -8*Math.cos(t/5.5)
				moon.position.set( moonPos.x, moonPos.y, moonPos.z );
				moonLight.position.set( moonPos.x, moonPos.y, moonPos.z )//.normalize()

				/*listBody[0].rotation.x = PI/2
				listBody[1].rotation.x = -PI/2*/
				
				renderer.render( scene, camera )
				t += 0.1
			}

			animate()
		</script>
	</body>
</html>