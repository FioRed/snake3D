<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>SNAKE</title>
		<style>
			body { margin: 0 }
			canvas { width: 100%; height: 100%}
		</style>
				
	</head>
	<body>
		<script src="js/pro.js"></script>
		
		<!-- SETTING SECTION -->
		View:
		<select id="SelectV">
		  <option value="0" select="selected">Perspective</option>
		  <option value="1">Above</option>
		  <option value="2">Snake</option>
		</select>
		
		<script>
			// const
			var PI = Math.PI
			var RIGHT = 0
			var UP = 1
			var LEFT = 2
			var DOWN = 3
			var t = 0 		// time
			var lev = 0		// level
            var keyFlag = true
			
			// ground
			var groundX = 10
			var groundY = 0.4
			var groundZ = 10
			
			// snake measures
			var segLen = 1
			var segRad = (0.9*segLen)/2 //0.4
			var muzzleRad = segLen/5 	//0.2
			
			// movement's variables
			var step = 1
			var view = 0 // 0:perspective 1:above 2:POV
			var dir = RIGHT
			var prevDir = RIGHT
			var dirList = [0,0,0]
            var bodyPos = [[-groundX/2+2.5,0.5],[-groundX/2+1.5,0.5],[-groundX/2+0.5,0.5]]
			
			// apple measures
			var appleRadius = segLen/8.5 	//0.12
			var appleTube = segLen/4.5		//0.22 (>appleRadius)
			
			var sunPos = { x: 3, y: 8, z: 0 }
			var moonPos = { x: -5, y: 5, z: 2 }
			
			var inGame = true
			var scene = new THREE.Scene()
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 )

			var renderer = new THREE.WebGLRenderer()
			//renderer.setClearColor(0x000000, 0.0)
            renderer.shadowMap.enabled = true;
            renderer.shadowMapSoft = true;
			renderer.setSize( window.innerWidth, window.innerHeight )
			document.body.appendChild( renderer.domElement )
            
			// materials
			var c_green_grass = new THREE.MeshPhongMaterial({color:0x507500})
			var c_black = new THREE.MeshPhongMaterial({color:0x000000})
			var c_white = new THREE.MeshPhongMaterial({color:0xefefef})
			var c_green_skin = new THREE.MeshPhongMaterial({color:0x00f000})
			var c_red_dark = new THREE.MeshPhongMaterial({color:0xa00000})
			var c_pink = new THREE.MeshPhongMaterial({color:0xc05050})
			
			var c_apple = new THREE.MeshPhongMaterial( {color: 0xe01000} )
			var c_brown = new THREE.MeshPhongMaterial( {color: 0x6B4423} )
			
			var c_sun = new THREE.MeshBasicMaterial( {color: 0xffffff, map: THREE.ImageUtils.loadTexture( 'sun_bright_texture.jpg')} )
			var c_moon = new THREE.MeshPhongMaterial( {color: 0xffffff, map: THREE.ImageUtils.loadTexture( 'moon_texture.jpg')} )
			
			// OBJECTS
			var BODY_PIVOT = new THREE.Object3D()
			BODY_PIVOT.position.y = -segLen
			var BODY_CYL = new THREE.Mesh( new THREE.CylinderGeometry( segRad-0.05, segRad, segLen, 32 ), c_green_skin )
			var BODY_TOR = new THREE.Mesh( new THREE.TorusGeometry( 1/2, segRad, 32, 96, PI/2 ), c_green_skin )
			var TAIL = new THREE.Mesh( new THREE.ConeGeometry( segRad, segLen, 32 ), c_green_skin )
			TAIL.rotation.z = PI
            
            // sky
            var width = groundX/2
            var sectors = 16
            //var radius =  width/2 // 4 lati
            //var radius = (Math.sqrt(2)+1)*width/2 // 8 lati
            var radius = 2.51*width // 16 lati
            var geometry = new THREE.BoxGeometry(width,2*groundX,0.5)
            for (var i=0; i<sectors; i++) {
                var side = new THREE.Mesh( geometry,
                    new THREE.MeshBasicMaterial( {color: 0xffffff, 
                    map: THREE.ImageUtils.loadTexture( 'milky'+(i%4)+'.jpg' )} ) ) //'_texture.jpg'
                side.position.set( radius*Math.sin(i*PI*2/sectors), 2, -radius*Math.cos(i*PI*2/sectors) )
                side.rotation.y = -i*PI*2/sectors
                scene.add( side )
            }
			
			// ground
            var geometry = new THREE.BoxGeometry(groundX,groundY,groundZ)
			var ground = new THREE.Mesh(geometry, c_green_grass)
			var mud = new THREE.Mesh(geometry, c_brown)
			mud.position.y = - groundY
			var gridHelper = new THREE.GridHelper( 10, 10, c_black, c_black);
			gridHelper.position.y = groundY/2 + 0.01
			ground.add( gridHelper )
			ground.add( mud )
			scene.add(ground)
			
			// centre of the SNAKE
			var pivotSnake = new THREE.Object3D()
			pivotSnake.position.set( bodyPos[0][0], segLen/2, bodyPos[0][1] )
			pivotSnake.rotation.z = -PI/2
			ground.add(pivotSnake)
			
			// Chin
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, 0, PI)
			var chin = new THREE.Mesh( geometry, c_green_skin )
			pivotSnake.add(chin)
			
			// centre of Head motion
			var pivotHead = new THREE.Object3D()
			pivotHead.position.y = -segLen/2
			chin.add(pivotHead)			
			
			// Head
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, PI, PI)
			var head = new THREE.Mesh( geometry, c_green_skin )
			head.position.y = segLen/2
			pivotHead.add(head)
			
			// Mouth (Chin + Head)
			var line = new THREE.Shape()
			line.moveTo( -segRad, -segLen/2 )
			line.lineTo( -muzzleRad, segLen/2 )
			line.lineTo( muzzleRad, segLen/2 )
			line.lineTo( segRad, -segLen/2)
			line.lineTo( -segRad, -segLen/2 )
			var extrudeSettings = { depth: -0.01, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var mouth_head = new THREE.Mesh( geometry, c_red_dark )
			var mouth_chin = new THREE.Mesh( geometry, c_red_dark )
			mouth_head.rotation.y = PI/2
			mouth_chin.rotation.y = PI/2
			head.add(mouth_head)
			chin.add(mouth_chin)
			
			// Tongue
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, -segLen/2 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var back_tongue = new THREE.Mesh( geometry, c_pink )
			back_tongue.rotation.y = PI/2
			back_tongue.position.x = -0.01
			chin.add(back_tongue)
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, segLen/2 )
			line.lineTo( -muzzleRad, segLen )
			line.lineTo( 0, 3*segLen/4 )
			line.lineTo( muzzleRad, segLen )
			line.lineTo( muzzleRad/2, segLen/2 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, 0 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var tongue = new THREE.Mesh( geometry, c_pink )
			tongue.rotation.y = PI/2
			tongue.position.x = -0.01
			chin.add(tongue)
			
			// Eyes
			var geometry = new THREE.SphereGeometry (segRad/4, 16, 16)
			var eyeR = new THREE.Mesh( geometry, c_white )
			eyeR.position.set(-segRad/2,0,segRad/2)
			head.add(eyeR)
			var eyeL = new THREE.Mesh( geometry, c_white )
			eyeL.position.set(-segRad/2,0,-segRad/2)
			head.add(eyeL)
			
			// levelUP
			var levelUP = function () {
				// replace tail with the body on actual seg
				pivotList[ lev ].remove( TAIL )
				pivotList[ lev ].add( BODY_CYL.clone() )
				// add the next pivot in the list
				pivotList.push( pivotList[lev].children[0] )
				// move to the next seg
				lev++
				console.log("levelUP >",lev)
				// add as child: next pivot, tail
				pivotList[ lev ].add( BODY_PIVOT.clone() )
				pivotList[ lev ].add( TAIL )
			}
			
			// Initial Body
			var pivotList = [ BODY_PIVOT.clone() ]
			pivotSnake.add( pivotList[0] )
			pivotList[0].add( BODY_PIVOT.clone() )
			pivotList[0].add( TAIL )
			
			// return if the obj is in an illegal position
			var invalidPos = function (obj) {
				// out of world
				if (Math.abs(obj.position.x) > groundX/2 ||
					Math.abs(obj.position.z) > groundZ/2 ) {
					console.log("out of world")
					return true
				}
				// on snake
                for (var p=0; p<bodyPos.length-1; p++) {
                    if ( obj.position.x == bodyPos[p][0] &&
                         obj.position.z == bodyPos[p][1] ) {
						console.log("on snake's body")
						return true
					}
                }
				return false
			}
			
			// Random apple position
			var randPosApple = function (){
				do { // find a possible new position
					apple.position.x = Math.round((Math.random() * (groundX-1)) - groundX/2) + 0.5
					apple.position.z = Math.round((Math.random() * (groundZ-1)) - groundZ/2) + 0.5
				} while (invalidPos(apple))
				console.log("An apple is appeared in",apple.position.x,",",apple.position.z)
			}
			
			// Apple
			var geometry = new THREE.TorusGeometry( appleRadius, appleTube, 32, 96 )
			var apple = new THREE.Mesh( geometry, c_apple )
			randPosApple()
			apple.position.y = appleTube + groundY/2
			apple.rotation.x = -PI/2
			ground.add( apple )
			
			// Petiole
			var geometry = new THREE.ConeGeometry( 0.05, appleTube, 16 )
			var petiole = new THREE.Mesh( geometry, c_brown )
			petiole.rotation.x = -PI/4
			petiole.position.z = appleTube
			apple.add( petiole )

			// Camera
			var refreshCamera = function (pos) {
				if ( view==2) { // POV
					if ( dir==RIGHT) {
						camera.position.set( pos.x-1, 1.5, pos.z )
						camera.lookAt( pos.x+2, 0, pos.z )
					}else if ( dir==LEFT ) {
						camera.position.set( pos.x+1, 1.5, pos.z )
						camera.lookAt( pos.x-2, 0, pos.z )
					}else if ( dir==UP ) {
						camera.position.set( pos.x, 1.5, pos.z+1 )
						camera.lookAt( pos.x, 0, pos.z-2 )
					}else if ( dir==DOWN ) {
						camera.position.set( pos.x, 1.5, pos.z-1 )
						camera.lookAt( pos.x, 0, pos.z+2 )
					}
				} else if ( view==0 ) { // perspective
					camera.position.set( 0, 7, 6 )
					camera.lookAt( 0, 0, 0 )
				} else if ( view==1 ) { // above
					camera.position.set( 0, 7, 0 ) 
					camera.lookAt( 0, 0, 0 )
				}
			}
			refreshCamera(view) // initial setting
			document.getElementById("SelectV").onchange = function(event) {
				view = parseFloat( event.target.value )
				refreshCamera( pivotSnake.position )
			}

			// Light
            scene.add ( new THREE.AmbientLight( c_white, 0.1 ) )
			var sunLight = new THREE.DirectionalLight( c_sun, 1.5 )
			scene.add( sunLight )
			var moonLight = new THREE.DirectionalLight( c_moon, 0.5 )
			scene.add( moonLight )
			var sun = new THREE.Mesh( new THREE.SphereGeometry( 1.5, 32, 32 ), c_sun )
			scene.add( sun )
			var moon = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 32 ), c_moon )
			scene.add( moon )           
            
            // SHADOWS 
            // castShadow = block light
            sunLight.castShadow = true
            moonLight.castShadow = true
            ground.castShadow = true
            //mud.castShadow = true
            chin.castShadow = true
            head.castShadow = true
            mouth_head.castShadow = true
            tongue.castShadow = true
            BODY_CYL.castShadow = true
            BODY_TOR.castShadow = true
            TAIL.castShadow = true
            apple.castShadow = true
            // receiveShadow = show shadow
            ground.receiveShadow = true
            //mud.receiveShadow = true
            mouth_chin.receiveShadow = true
            tongue.receiveShadow = true
            BODY_CYL.receiveShadow = true
            BODY_TOR.receiveShadow = true
            TAIL.receiveShadow = true
            
			levelUP() // start with one bodySeg
			
            var nextMoves = []
			document.addEventListener("keydown", onDocumentKeyDown, true)
			function onDocumentKeyDown(event) {
                var keyCode = event.which
                if ( keyCode>=37 && keyCode<=40                 // directional key pressed 
                    && nextMoves.length<4                       // max macro = 3
                    && (nextMoves[nextMoves.length-1]!=keyCode  // different from the last one
                        || view == 2) )                         //    but not in POV
                    nextMoves.push(keyCode)
                
                if ( keyCode == 86 ) { // change view - v
                    view = (view+1)%3 
                    refreshCamera( pivotSnake.position )
                }
                
                // TEST: move and levelUP
                //if ( keyCode>=37 && keyCode<=40 ) move()
                /*if ( keyCode == 13 ){
                    dirList.push(dirList[lev])
                    bodyPos.push(bodyPos[lev])
                    levelUP()
                }*/
			}
			
			var move = function () {
				// move the snake (pivotSnake)
				if ( dir == RIGHT ){ 		// RIGHT
					pivotSnake.position.x += step
				} else if ( dir == LEFT ){	// LEFT
					pivotSnake.position.x -= step
				} else if ( dir == DOWN ){	// DOWN
					pivotSnake.position.z += step
				} else if( dir == UP ){ 	// UP
					pivotSnake.position.z -= step
				}
				if (invalidPos(pivotSnake)) return false
				
				// add head elements to the flow lists
				dirList.unshift(dir)
                bodyPos.unshift([pivotSnake.position.x, pivotSnake.position.z])
                
                // check if it ate an apple
				if (apple.position.x == pivotSnake.position.x &&
					apple.position.z == pivotSnake.position.z) {
					levelUP()
					randPosApple()
				} else {
                    dirList.pop()
                    bodyPos.pop()
                }
				
				// rotate the head (and the camera if in POV)
				pivotSnake.rotation.y = dirList[0] * PI/2
				if ( view==2 ) refreshCamera( pivotSnake.position )
				
				// rotate the rest of the body
				for ( var i=0; i<lev; i++ ) {
					var turn = dirList[i+1] - dirList[i] // dirList[0] is the head dir
					if ( turn ) { // turn!
						if (turn == 3) turn = -1 // turn to right [-1,3]
						if (turn == -3) turn = 1 // turn to left  [1,-3]
						pivotList[i].rotation.x = -turn*PI/2
						var tor = BODY_TOR.clone()
						tor.rotation.set( 0, turn*PI/2, 0 )
						tor.position.set( 0, -0.5, turn*0.5 )
						pivotList[i].remove( pivotList[i].children[1] )
						pivotList[i].add( tor )
					} else if ( dirList[i+1] != dirList[i+2] ) { // before it was a Tor
						pivotList[i].rotation.x = 0
						pivotList[i].remove( pivotList[i].children[1] )
						pivotList[i].add( BODY_CYL.clone() )
					}
				}
				
				
				return true
			}
			
            var redPos = 0
			var game = function () {
				requestAnimationFrame( game )
                if (inGame) {
                    if ( Math.round(t*10)%(20-Math.floor(lev/5)) == 0 ) {
                        if (nextMoves.length) {
                            key = nextMoves.shift()
                            if ( view==2) { // relative movement (POV)
                                if ( key==39 ) dir = (dir+3)%4 // turn RIGHT
                                else if ( key==37) dir = (dir+1)%4 // turn LEFT
                            } else { // absolute movement
                                if (key == 39 && dir != LEFT ) { // RIGHT
                                    dir = RIGHT
                                } else if (key == 40 && dir != UP ) { // DOWN
                                    dir = DOWN
                                } else if (key == 37 && dir != RIGHT ) { // LEFT
                                    dir = LEFT
                                } else if (key == 38 && dir != DOWN ) { // UP
                                    dir = UP
                                }
                            }
                        }
                        inGame = move()
                    }
                    
                    // snake constant motion
                    pivotHead.rotation.z = PI/6*Math.sin(t) + PI/6
                    tongue.position.y = segLen/2*Math.sin(t) - segLen/2
                } else if ( Math.round(t*10)%2 == 0 ) {
                    pivotList[redPos++%pivotList.length].children[1].material = c_green_skin
                    pivotList[redPos%pivotList.length].children[1].material = c_red_dark
                }
                
                // apple motion
				apple.position.y = Math.sin(t/2)/10+0.1 + appleTube+groundY/2
				apple.rotation.z += 0.05
				
				// light
				sunPos.y = 8*Math.cos(t/20)
				sunPos.z = -8*Math.sin(t/20)
				sun.position.set( sunPos.x, sunPos.y, sunPos.z )
				sunLight.position.set( sunPos.x, sunPos.y, sunPos.z )//.normalize()
				
                moonPos.y = 8*Math.cos(t/22 + PI)
				moonPos.z = 8*Math.sin(t/22)
				moon.position.set( moonPos.x, moonPos.y, moonPos.z );
				moonLight.position.set( moonPos.x, moonPos.y, moonPos.z )//.normalize()
				
				//renderer.render( backgroundScene, backgroundCamera )
				renderer.render( scene, camera )
				t += 0.1
			}
			
			game()
		</script>
	</body>
</html>