<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>SNAKE</title>
		<style>
			body { margin: 0 }
			canvas { width: 100%; height: 100%; background-color: white }
		</style>
	</head>
	<body>
		<script src="js/pro.js"></script>
		
		<script>
			var PI = Math.PI
			var RIGHT = 0
			var UP = 1
			var LEFT = 2
			var DOWN = 3
			var t = 0 		// time
			
			var groundX = 10
			var groundY = 0.5
			var groundZ = 10
			
			var segLen = 1
			var segRad = 0.5
			var muzzleRad= 0.2
			
			var lev = 0
			var listBody = []
			var dir = RIGHT // current direction
			var theta = [ 0, 0, 0 ] // Chin+Head, Body, Tail
			
			var step = 1
			
			var appleRadius = 0.12
			var appleTube = 0.22 // > appleRadius
			
			var sunPos = { x: 5, y: 8, z: 0 }
			var moonPos = { x: -5, y: 5, z: 2 }
			
			var scene = new THREE.Scene()
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 )

			var renderer = new THREE.WebGLRenderer()
			//renderer.setClearColor(0xEEEEEE);
			renderer.setSize( window.innerWidth, window.innerHeight )
			document.body.appendChild( renderer.domElement )
			
			// materials
			var c_grass = new THREE.MeshPhongMaterial({color:0x507500})
			var c_black = new THREE.MeshPhongMaterial({color:0x000000})
			var c_skin = new THREE.MeshPhongMaterial({color:0x00f000})
			var c_mouth = new THREE.MeshPhongMaterial({color:0xa00000})
			var c_apple = new THREE.MeshPhongMaterial( {color: 0xe01000} )
			var c_brown = new THREE.MeshPhongMaterial( {color: 0x6B4423} )
			var c_sun = new THREE.MeshPhongMaterial( {color: 0xffefef} )
			var c_moon = new THREE.MeshPhongMaterial( {color: 0x0050f0} )
			
			// ground
			var ground = new THREE.Mesh(new THREE.BoxGeometry(groundX,groundY,groundZ), c_grass)
			ground.position.y = -0.25
			var geometryX = new THREE.Geometry()
			var geometryZ = new THREE.Geometry()
			for (var i=-5; i<=5; i++) {
				if (i%2) {
					geometryX.vertices.push(new THREE.Vector3( i, 0.26, -5) )
					geometryX.vertices.push(new THREE.Vector3( i, 0.26, 5) )
					geometryZ.vertices.push(new THREE.Vector3( -5, 0.26, i) )
					geometryZ.vertices.push(new THREE.Vector3( 5, 0.26, i) )
				} else {
					geometryX.vertices.push(new THREE.Vector3( i, 0.26, 5) )
					geometryX.vertices.push(new THREE.Vector3( i, 0.26, -5) )
					geometryZ.vertices.push(new THREE.Vector3( 5, 0.26, i) )
					geometryZ.vertices.push(new THREE.Vector3( -5, 0.26, i) )
				}
			}
			var lineX = new THREE.Line( geometryX, c_black )
			var lineZ = new THREE.Line( geometryZ, c_black )
			ground.add(lineX) // add as child
			ground.add(lineZ) // add as child
			scene.add(ground)
			
			// centre of the SNAKE
			var pivotSnake = new THREE.Object3D()
			pivotSnake.position.y = segLen/2
			pivotSnake.rotation.z = -PI/2
			ground.add(pivotSnake)
			
			// Chin
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, 0, PI)
			var chin = new THREE.Mesh( geometry, c_skin )
			pivotSnake.add(chin)
			
			// centre of Head motion
			var pivotHead = new THREE.Object3D()
			pivotHead.position.y = -segLen/2
			chin.add(pivotHead)			
			
			// Head
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, PI, PI)
			var head = new THREE.Mesh( geometry, c_skin )
			head.position.y = segLen/2
			pivotHead.add(head)
			
			// Mouth (Chin + Head)
			var line = new THREE.Shape()
			line.moveTo( -segRad, -segLen/2 )
			line.lineTo( -muzzleRad, segLen/2 )
			line.lineTo( muzzleRad, segLen/2 )
			line.lineTo( segRad, -segLen/2)
			line.lineTo( -segRad, -segLen/2 )
			var extrudeSettings = { depth: -0.01, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var mouth_head = new THREE.Mesh( geometry, c_mouth )
			var mouth_chin = new THREE.Mesh( geometry, c_mouth )
			mouth_head.rotation.y = PI/2
			mouth_chin.rotation.y = PI/2
			head.add(mouth_head)
			chin.add(mouth_chin)
			
			// Body
			var geometryBody = new THREE.CylinderGeometry( segRad-0.1, segRad, segLen, 32 )
			var body = new THREE.Mesh( geometryBody, c_skin )
			body.position.y = -segLen
			listBody.push( body )
			chin.add( body )
			
			// Tail
			var geometry = new THREE.ConeGeometry( segRad, segLen, 32 )
			var tail = new THREE.Mesh( geometry, c_skin )
			tail.position.y = -segLen
			tail.rotation.x = PI
			listBody[ 0 ].add( tail )
			
			// levelUP : lev++, add BodySeg, (spawn of apple)
			var levelUP = function () {
				var body = new THREE.Mesh( geometryBody, c_skin )
				body.position.y = -segLen
				listBody.push( body )
				listBody[ lev ].add( body )
				listBody[ lev ].remove( tail )
				theta.push ( theta[lev] )
				lev++;
				listBody[ lev ].add( tail )
			}
			
			// Apple
			var geometry = new THREE.TorusGeometry( appleRadius, appleTube, 32, 96 )
			var apple = new THREE.Mesh( geometry, c_apple )
			apple.position.y = appleTube + groundY/2
			apple.rotation.x = -PI/2
			//ground.add( apple )
			
			// Petiole
			var geometry = new THREE.ConeGeometry( 0.05, appleTube, 16 )
			var petiole = new THREE.Mesh( geometry, c_brown )
			petiole.rotation.x = -PI/4
			petiole.position.z = appleTube
			apple.add( petiole )

			// Camera
			camera.position.set(0,5,7) // prospection
			//camera.position.set(0,7,0) // up
			camera.lookAt( 0, 0, 0 )

			// Light
			var sunLight = new THREE.DirectionalLight( c_sun, 1.5 );
			scene.add( sunLight );
			var moonLight = new THREE.DirectionalLight( c_moon, 0.5 );
			scene.add( moonLight );
			var sun = new THREE.Mesh( new THREE.SphereGeometry( 1.5, 32, 32 ), c_sun )
			scene.add( sun )
			var moon = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 32 ), c_moon )
			scene.add( moon )
			 
			document.addEventListener("keydown", onDocumentKeyDown, false)
			function onDocumentKeyDown(event) {
				var keyCode = event.which
				//console.log(keyCode)
				if ( keyCode == 39 ){ 
					dir = RIGHT
				} else if ( keyCode == 37 ){
					dir = LEFT
				} else if ( keyCode == 40 ){
					dir = DOWN
				} else if( keyCode == 38 ){
					dir = UP
				}
				pivotSnake.rotation.y = dir * PI/2
				move()
				
				if ( keyCode == 13 )
					levelUP()
			}
			
			var checkPos = function (){
				if (pivotSnake.position.x >= groundX/2){
					pivotSnake.position.x = -groundX/2
				}
				if (pivotSnake.position.x < -groundX/2){
					pivotSnake.position.x = groundX/2
				}
				if (pivotSnake.position.z >= groundZ/2){
					pivotSnake.position.z = -groundZ/2
				}
				if (pivotSnake.position.z < -groundX/2){
					pivotSnake.position.z = groundX/2
				}
			}
			
			var move = function(){
				if ( dir == RIGHT ){ 		// destra
					pivotSnake.position.x += step
				} else if ( dir == LEFT ){	// sinistra
					pivotSnake.position.x -= step
				} else if ( dir == DOWN ){	// giÃ¹
					pivotSnake.position.z += step
				} else if( dir == UP ){ 	// su
					pivotSnake.position.z -= step
				}
				
				theta.unshift( dir )	// add the actual direction
				theta.pop()				// remove last direction
				console.log(theta)
				
				for (var i=0; i<=lev; i++){
					// theta start with the head
					// the i-th bodySeg direction correspond to the the (i+1)-th theta
					var diff = theta[i]-theta[i+1]
					listBody[i].rotation.x =  diff * PI/2
					/*if ( diff==1 || diff==-3 ) 	// counterclockwise > left
						listBody[i].rotation.x +=  -PI/4
					if ( diff==-1 || diff==3 )	// clockwise > right
						listBody[i].rotation.x +=  -PI/4*/
				}
				
				// check if the snake reaches the apple -> level UP
				if (Math.round(pivotSnake.position.x) == Math.round(apple.position.x) && 
					Math.round(pivotSnake.position.y) == Math.round(apple.position.z)) {
					console.log("level UP")
					levelUP()
					}
			}
			
			
			var animate = function () {
				requestAnimationFrame( animate )
				checkPos()
				//move()
				
				pivotHead.rotation.z = PI/6*Math.sin(t)+PI/6
				apple.position.y = Math.sin(t/2)/10+0.1 + appleTube+groundY/2
				apple.rotation.z += 0.05
				
				sunPos.y = 8*Math.sin(t/6)
				sunPos.z = 8*Math.cos(t/6)
				sun.position.set( sunPos.x, sunPos.y, sunPos.z )
				sunLight.position.set( sunPos.x, sunPos.y, sunPos.z )//.normalize()
				//moonPos.y = -8*Math.sin(t/5.5)
				//moonPos.z = -8*Math.cos(t/5.5)
				moon.position.set( moonPos.x, moonPos.y, moonPos.z );
				moonLight.position.set( moonPos.x, moonPos.y, moonPos.z )//.normalize()

				renderer.render( scene, camera )
				t += 0.1
			}

			animate()
		</script>
	</body>
</html>