<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>SNAKE</title>
		<style>
			body { margin: 0 }
			canvas { width: 100%; height: 100%}
		</style>
				
	</head>
	<body>
		<script src="js/pro.js"></script>
		
		<!-- SETTING SECTION -->
		View:
		<select id="SelectV">
		  <option value="0" select="selected">Perspective</option>
		  <option value="1">Above</option>
		  <option value="2">Snake</option>
		</select>
		
		<script>
			// const
			var PI = Math.PI
			var RIGHT = 0
			var UP = 1
			var LEFT = 2
			var DOWN = 3
			var t = 0 		// time
			var lev = 0		// level
            var t_step = 20 // time between 2 steps
			
			// ground and background
			var groundX = 10
			var groundY = 0.4
			var groundZ = 10
			
			// snake measures
			var segLen = 1
			var segRad = (0.9*segLen)/2 //0.4
			var muzzleRad = segLen/5 	//0.2
			
			// movement's variables
			var step = 1
			var view = 0 // 0:perspective 1:above 2:POV
			var dir = RIGHT
			var dirList = [0,0,0]
            var bodyPos = [[-groundX/2+2.5,0.5],[-groundX/2+1.5,0.5],[-groundX/2+0.5,0.5]]
			
			// apple measures
			var appleRadius = segLen/8.5 	//0.12
			var appleTube = segLen/4.5		//0.22 (>appleRadius)
			
			var sunPos = { x: 3, y: 8, z: 0 }
			var moonPos = { x: -5, y: 5, z: 2 }
			
			var inGame = true
			var scene = new THREE.Scene()
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 )

			var renderer = new THREE.WebGLRenderer()
			//renderer.setClearColor(0x000000, 0.0)
            renderer.shadowMap.enabled = true;
            renderer.shadowMapSoft = true;
			renderer.setSize( window.innerWidth, window.innerHeight )
			document.body.appendChild( renderer.domElement )
            
			// materials
			var c_green_grass = new THREE.MeshPhongMaterial({color:0x507500})
			var c_black = new THREE.MeshPhongMaterial({color:0x000000})
			var c_white = new THREE.MeshPhongMaterial({color:0xefefef})
			var c_green_skin = new THREE.MeshPhongMaterial({color:0x00f000})
			var c_red_dark = new THREE.MeshPhongMaterial({color:0xa00000})
			var c_pink = new THREE.MeshPhongMaterial({color:0xc05050})
			
			var c_apple = new THREE.MeshPhongMaterial( {color: 0xe01000} )
			var c_brown = new THREE.MeshPhongMaterial( {color: 0x6B4423} )
            
			var c_sun = new THREE.MeshBasicMaterial( {color: 0xffffff, map: THREE.ImageUtils.loadTexture( 'sun_bright_texture.jpg')} )
			var c_moon = new THREE.MeshPhongMaterial( {color: 0xffffff, map: THREE.ImageUtils.loadTexture( 'moon_texture.jpg')} )
			
			// OBJECTS
			var BODY_PIVOT = new THREE.Object3D()
			BODY_PIVOT.position.y = -segLen
			var BODY_CYL = new THREE.Mesh( new THREE.CylinderGeometry( segRad-0.05, segRad, segLen, 32 ), c_green_skin )
			var BODY_TOR = new THREE.Mesh( new THREE.TorusGeometry( 1/2, segRad, 32, 96, PI/2 ), c_green_skin )
			var TAIL = new THREE.Mesh( new THREE.ConeGeometry( segRad, segLen, 32 ), c_green_skin )
			TAIL.rotation.z = PI
            
            // sky
            var pivotBG = new THREE.Object3D()
            var width = groundX/2
            var sectors = 16
            //var radius =  width/2 // 4 lati
            //var radius = (Math.sqrt(2)+1)*width/2 // 8 lati
            var radius = 2.51*width // 16 lati
            var geometry = new THREE.BoxGeometry(width,2*groundX,0.5)
            for (var i=0; i<sectors; i++) {
                var side = new THREE.Mesh( geometry,
                    new THREE.MeshBasicMaterial( {color: 0xffffff, 
                    map: THREE.ImageUtils.loadTexture( 'milky_low'+(i%4)+'.jpg' )} ) ) //'_texture.jpg'
                side.position.set( radius*Math.sin(i*PI*2/sectors), 2, -radius*Math.cos(i*PI*2/sectors) )
                side.rotation.y = -i*PI*2/sectors
                pivotBG.add( side ) // pivotBG -> child 0..sectors-1
            }
            scene.add( pivotBG ) // scene -> child 0
			
			// ground
            var geometry = new THREE.BoxGeometry(groundX,groundY,groundZ)
			var ground = new THREE.Mesh(geometry, c_green_grass)
			var mud = new THREE.Mesh(geometry, c_brown)
			mud.position.y = - groundY
			var gridHelper = new THREE.GridHelper( 10, 10, c_black, c_black);
			gridHelper.position.y = groundY/2 + 0.01
			ground.add( gridHelper ) // ground -> child 0
			ground.add( mud ) // ground -> child 1
			scene.add(ground) // scene -> child 1
			
			// centre of the SNAKE
			var pivotSnake = new THREE.Object3D()
			pivotSnake.position.set( bodyPos[0][0], segLen/2, bodyPos[0][1] )
			pivotSnake.rotation.z = -PI/2
			ground.add(pivotSnake) //ground -> child 2
			
			// Chin
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, 0, PI)
			var chin = new THREE.Mesh( geometry, c_green_skin )
			pivotSnake.add(chin) // pivotSnake -> child 0
			
			// centre of Head motion
			var pivotHead = new THREE.Object3D()
			pivotHead.position.y = -segLen/2
			chin.add(pivotHead)	// chin -> child 0		
			
			// Head
			var geometry = new THREE.CylinderGeometry( muzzleRad, segRad, segLen, 32, 1, false, PI, PI)
			var head = new THREE.Mesh( geometry, c_green_skin )
			head.position.y = segLen/2
			pivotHead.add(head) // pivotHead -> child 0
			
			// Mouth (Chin + Head)
			var line = new THREE.Shape()
			line.moveTo( -segRad, -segLen/2 )
			line.lineTo( -muzzleRad, segLen/2 )
			line.lineTo( muzzleRad, segLen/2 )
			line.lineTo( segRad, -segLen/2)
			line.lineTo( -segRad, -segLen/2 )
			var extrudeSettings = { depth: -0.01, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var mouth_head = new THREE.Mesh( geometry, c_red_dark )
			var mouth_chin = new THREE.Mesh( geometry, c_red_dark )
			mouth_head.rotation.y = PI/2
			mouth_chin.rotation.y = PI/2
			head.add(mouth_head) // head -> child 0
			chin.add(mouth_chin) // chin -> child 1
			
			// Tongue
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( muzzleRad/2, -segLen/2 )
			line.lineTo( -muzzleRad/2, -segLen/2 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var back_tongue = new THREE.Mesh( geometry, c_pink )
			back_tongue.rotation.y = PI/2
			back_tongue.position.x = -0.01
			chin.add(back_tongue) // chin -> child 2
			var line = new THREE.Shape()
			line.moveTo( -muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, segLen/2 )
			line.lineTo( -muzzleRad, segLen )
			line.lineTo( 0, 3*segLen/4 )
			line.lineTo( muzzleRad, segLen )
			line.lineTo( muzzleRad/2, segLen/2 )
			line.lineTo( muzzleRad/2, 0 )
			line.lineTo( -muzzleRad/2, 0 )
			var extrudeSettings = { depth: 0.05, bevelEnabled: false}
			var geometry = new THREE.ExtrudeGeometry( line, extrudeSettings )
			var tongue = new THREE.Mesh( geometry, c_pink )
			tongue.rotation.y = PI/2
			tongue.position.x = -0.01
			chin.add(tongue) // chin -> child 3
			
			// Eyes
			var geometry = new THREE.SphereGeometry (segRad/4, 16, 16)
			var eyeR = new THREE.Mesh( geometry, c_white )
			eyeR.position.set(-segRad/2,0,segRad/2)
			head.add(eyeR) // head -> child 1
			var eyeL = new THREE.Mesh( geometry, c_white )
			eyeL.position.set(-segRad/2,0,-segRad/2)
			head.add(eyeL) // head -> child 2
			
			// levelUP
			var levelUP = function () {
				// replace tail with the body on actual seg
				pivotList[ lev ].remove( TAIL ) // pivotList[lev] -> remove 1
				pivotList[ lev ].add( BODY_CYL.clone() ) // pivotList[lev] -> child 1
				// add the next pivot in the list
				pivotList.push( pivotList[lev].children[0] )
				// move to the next seg
				lev++
                t_step = 20-Math.floor(lev/5)
				console.log("levelUP >",lev)
				// add as child: next pivot, tail
				pivotList[ lev ].add( BODY_PIVOT.clone() ) // pivotList[lev] -> child 0
				pivotList[ lev ].add( TAIL ) // pivotList[lev] -> child 1
			}
			
			// Initial Body
			var pivotList = [ BODY_PIVOT.clone() ]
			pivotSnake.add( pivotList[0] ) // pivotSnake -> child 1
			pivotList[0].add( BODY_PIVOT.clone() ) // pivotList[0] -> child 0
			pivotList[0].add( TAIL ) // pivotList[0] -> child 1
			
			// return if the obj is in an illegal position
			var invalidPos = function (obj) {
				// out of world
				if (Math.abs(obj.position.x) > groundX/2 ||
					Math.abs(obj.position.z) > groundZ/2 ) {
					console.log("out of world")
					return true
				}
				// on snake
                for (var p=0; p<bodyPos.length-1; p++) {
                    if ( obj.position.x == bodyPos[p][0] &&
                         obj.position.z == bodyPos[p][1] ) {
						console.log("on snake's body")
						return true
					}
                }
				return false
			}
			
			// Random apple position
			var randPosApple = function (){
				do { // find a possible new position
					apple.position.x = Math.round((Math.random() * (groundX-1)) - groundX/2) + 0.5
					apple.position.z = Math.round((Math.random() * (groundZ-1)) - groundZ/2) + 0.5
				} while (invalidPos(apple))
				console.log("An apple is appeared in",apple.position.x,",",apple.position.z)
			}
			
			// Apple
			var geometry = new THREE.TorusGeometry( appleRadius, appleTube, 32, 96 )
			var apple = new THREE.Mesh( geometry, c_apple )
			randPosApple()
			apple.position.y = appleTube + groundY/2
			apple.rotation.x = -PI/2
			ground.add( apple ) // ground -> child 3
			
			// Petiole
			var geometry = new THREE.ConeGeometry( 0.05, appleTube, 16 )
			var petiole = new THREE.Mesh( geometry, c_brown )
			petiole.rotation.x = -PI/4
			petiole.position.z = appleTube
			apple.add( petiole ) // apple -> child 0

			// Camera
			var refreshCamera = function (pos) {
				if ( view==2) { // POV
					if ( dir==RIGHT) {
						camera.position.set( pos.x-1, 1.5, pos.z )
						camera.lookAt( pos.x+2, 0, pos.z )
					}else if ( dir==LEFT ) {
						camera.position.set( pos.x+1, 1.5, pos.z )
						camera.lookAt( pos.x-2, 0, pos.z )
					}else if ( dir==UP ) {
						camera.position.set( pos.x, 1.5, pos.z+1 )
						camera.lookAt( pos.x, 0, pos.z-2 )
					}else if ( dir==DOWN ) {
						camera.position.set( pos.x, 1.5, pos.z-1 )
						camera.lookAt( pos.x, 0, pos.z+2 )
					}
				} else if ( view==0 ) { // perspective
					camera.position.set( 0, 7, 6 )
					camera.lookAt( 0, 0, 0 )
				} else if ( view==1 ) { // above
					camera.position.set( 0, 7, 0 ) 
					camera.lookAt( 0, 0, 0 )
				}
			}
			refreshCamera(view) // initial setting
			document.getElementById("SelectV").onchange = function(event) {
				view = parseFloat( event.target.value )
				refreshCamera( pivotSnake.position )
			}

			// Ambient Light
            scene.add ( new THREE.AmbientLight( c_white, 0.1 ) ) // scene -> child 2
            // Sun
            var pivotSun = new THREE.Object3D()
			scene.add(pivotSun) // scene -> child 3
			pivotSun.add( new THREE.DirectionalLight( c_sun, 1.5 ) ) // pivotSun -> child 0, LIGHT
			pivotSun.add( new THREE.Mesh( new THREE.SphereGeometry( 1.5, 32, 32 ), c_sun ) ) // pivotSun -> child 1, SPHERE
            // Moon
            var pivotMoon = new THREE.Object3D()
			scene.add(pivotMoon) // scene -> child 4
			pivotMoon.add( new THREE.DirectionalLight( c_moon, 0.5 ) ) // pivotMoon -> child 0, LIGHT
			pivotMoon.add( new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 32 ), c_moon ) ) // pivotMoon -> child 1, SPHERE 
            
            // SHADOWS 
            // castShadow = block light
            pivotSun.children[0].castShadow = true
            pivotMoon.children[0].castShadow = true
            ground.castShadow = true
            //mud.castShadow = true
            chin.castShadow = true
            head.castShadow = true
            mouth_head.castShadow = true
            tongue.castShadow = true
            BODY_CYL.castShadow = true
            BODY_TOR.castShadow = true
            TAIL.castShadow = true
            apple.castShadow = true
            // receiveShadow = show shadow
            ground.receiveShadow = true
            //mud.receiveShadow = true
            mouth_chin.receiveShadow = true
            tongue.receiveShadow = true
            BODY_CYL.receiveShadow = true
            BODY_TOR.receiveShadow = true
            TAIL.receiveShadow = true
            
			levelUP() // start with one bodySeg
			
            var nextMoves = []
			document.addEventListener("keydown", onDocumentKeyDown, true)
			function onDocumentKeyDown(event) {
                var keyCode = event.which
                if ( keyCode>=37 && keyCode<=40                 // directional key pressed 
                    && nextMoves.length<4                       // max macro = 3
                    && (nextMoves[nextMoves.length-1]!=keyCode  // different from the last one
                        || view == 2) )                         //    but not in POV
                    nextMoves.push(keyCode)
                
                if ( keyCode == 86 ) { // change view - v
                    view = (view+1)%3 
                    refreshCamera( pivotSnake.position )
                }
                
                // TEST: move and levelUP
                //if ( keyCode>=37 && keyCode<=40 ) move()
                if ( keyCode == 13 ){
                    dirList.push(dirList[lev])
                    bodyPos.push(bodyPos[lev])
                    levelUP()
                }
			}
			
			var move = function () {
				// move the snake (pivotSnake)
                if ( dir == RIGHT ){ 		// RIGHT
					pivotSnake.position.x += step
				} else if ( dir == LEFT ){	// LEFT
					pivotSnake.position.x -= step
				} else if ( dir == DOWN ){	// DOWN
					pivotSnake.position.z += step
				} else if( dir == UP ){ 	// UP
					pivotSnake.position.z -= step
				}
				//if (invalidPos(pivotSnake)) return false
				
				// add head elements to the flow lists
				dirList.unshift(dir)
                bodyPos.unshift([pivotSnake.position.x, pivotSnake.position.z])
                
                // check if it ate an apple
				if (apple.position.x == pivotSnake.position.x &&
					apple.position.z == pivotSnake.position.z) {
					levelUP()
					randPosApple()
				} else {
                    dirList.pop()
                    bodyPos.pop()
                }
				
				// rotate the head (and the camera if in POV)
				pivotSnake.rotation.y = dirList[0] * PI/2
				if ( view==2 ) refreshCamera( pivotSnake.position )
				
				// rotate the rest of the body
				for ( var i=0; i<lev; i++ ) {
					var turn = dirList[i+1] - dirList[i] // dirList[0] is the head dir
					if ( turn ) { // turn!
						if (turn == 3) turn = -1 // turn to right [-1,3]
						if (turn == -3) turn = 1 // turn to left  [1,-3]
						pivotList[i].rotation.x = -turn*PI/2
						var tor = BODY_TOR.clone()
						tor.rotation.set( 0, turn*PI/2, 0 )
						tor.position.set( 0, -0.5, turn*0.5 )
						pivotList[i].remove( pivotList[i].children[1] ) // pivotList[i] -> remove 1
						pivotList[i].add( tor ) // pivotList[i] -> child 1
					} else if ( dirList[i+1] != dirList[i+2] ) { // before it was a Tor
						pivotList[i].rotation.x = 0
						pivotList[i].remove( pivotList[i].children[1] ) // pivotList[i] -> remove 1
						pivotList[i].add( BODY_CYL.clone() ) // pivotList[i] -> child 1
					}
				}
				return true
			}
            
            var moveBody = function () {
                s = (t % t_step) / t_step
                chin.position.y = s // HEAD
                // FIRST BODYSEC
                if (dirList[0] != dirList[1]) { // before a TOR
                    if (pivotSnake.children.length==2) pivotSnake.add( BODY_CYL.clone() ) // pivotSnake -> child 2
                    else if ( s==0 ) pivotSnake.remove( pivotSnake.children[2] ) // pivotSnake -> remove 2
                    else { // expand to keep the body connected
                        pivotSnake.children[2].position.y = -segLen/2+s/2
                        pivotSnake.children[2].scale.y = s
                    }
                } else pivotList[0].children[1].position.y = s
                
                // BODY
				for ( var i=0; i<lev; i++ ) {
                    // dir[0] <-> head direction
                    // i-th pivot <-> (i+1)-th dir
                    if (dirList[i+1] == dirList[i]) { // same direction == not a TOR
                        if ( i>0 ) {
                            if (dirList[i+1] != dirList[i-1]) { // after a TOR : collapse
                                pivotList[i].children[1].position.y = s/2
                                pivotList[i].children[1].scale.y = 1-s
                            } else  // move as a rigid body
                                pivotList[i].children[1].position.y = s
                        }
                        if ( i<lev-1 ) {
                            if (dirList[i+1] != dirList[i+2]) { // before a TOR : create a clone to keep the snake compact
                                if (pivotList[i].children.length==2) pivotList[i].add( BODY_CYL.clone() ) // pivotList[i] -> child 2
                                else if (s == 0) pivotList[i].remove( pivotList[i].children[2] ) // pivotList[i] -> remove 2
                            }
                        }
                    }
				}
                TAIL.position.y = s
            }
			
            var redPos = 0
			var game = function () {
				requestAnimationFrame( game )
                if (inGame) {
                    
                    pivotHead.rotation.z = PI/6*Math.sin(t/10) + PI/6 // mouth
                    tongue.position.y = segLen/2*Math.sin(t/10) - segLen/2 // tongue
                    
                    moveBody()
                  
                    // skeleton motion (real motion)
                    if ( t % t_step == 0 ) {
                        if (nextMoves.length) {
                            key = nextMoves.shift()
                            if ( view==2) { // relative movement (POV)
                                if ( key==39 ) dir = (dir+3)%4 // turn RIGHT
                                else if ( key==37) dir = (dir+1)%4 // turn LEFT
                            } else { // absolute movement
                                if (key == 39 && dir != LEFT ) { // RIGHT
                                    dir = RIGHT
                                } else if (key == 40 && dir != UP ) { // DOWN
                                    dir = DOWN
                                } else if (key == 37 && dir != RIGHT ) { // LEFT
                                    dir = LEFT
                                } else if (key == 38 && dir != DOWN ) { // UP
                                    dir = UP
                                }
                            }
                        }
                        inGame = move()
                    }
                    
                    
                } else if ( t % 2 == 0 ) { // gameover animation
                    pivotList[redPos++%pivotList.length].children[1].material = c_green_skin
                    pivotList[redPos%pivotList.length].children[1].material = c_red_dark
                }
                
                // apple motion
				apple.position.y = Math.sin(t/20)/10+0.1 + appleTube+groundY/2
				apple.rotation.z += 0.05
                
                // background rotation
                pivotBG.rotation.y += 0.0001
				
				// light
				sunPos.y = 8*Math.cos(t/200)
				sunPos.z = -8*Math.sin(t/200)
				pivotSun.position.set( sunPos.x, sunPos.y, sunPos.z )
				//sunLight.position.set( sunPos.x, sunPos.y, sunPos.z )//.normalize()
				
                moonPos.y = 8*Math.cos(t/220 + PI)
				moonPos.z = 8*Math.sin(t/220)
				pivotMoon.position.set( moonPos.x, moonPos.y, moonPos.z );
				//moonLight.position.set( moonPos.x, moonPos.y, moonPos.z )//.normalize()
				
				//renderer.render( backgroundScene, backgroundCamera )
				renderer.render( scene, camera )
				//t = Math.round(t*10+2)/10 // TEST: slow motion
                t += 1
			}
			
			game()
		</script>
	</body>
</html>

<!-- HIERARCHICAL TREE 
                     /  side0                                                                    /  moouth_head
         /  pivotBG |   ...                                          /  pivot_head  <   head    |   eyeR
        |            \  side16                                      |                            \  eyeL
        |                                            /  chin        |   mouth_chin
        |            /  GridHelper                  |               |   back_tongue 
        |   ground  |   mud                         |                \  tongue 
        |           |   pivotSnake  ----------------|                                            /  body_pivot(lev) <   body_pivot(lev+1)
scene   |            \  apple       <   petiole     |                                /  ...     |
        |                                           |                /  body_pivot1 |            \  tail
        |   ambientLight                             \  body_pivot0 |                \  body_tor
        |                                                            \  body_cyl
        |   pivotSun    /   light                       
        |               \   sphere                                         
        |           
         \  pivotMoon   /   light
                        \   sphere
-->